import "@stdlib/tvm-dicts"

// ops
const OP_VERIFY = stringCrc32("op::verify")

// sizes
const `verifier::P1_SIZE` = 48 * 8
const `verifier::P2_SIZE` = 96 * 8

// input constants (IC0 is the base term)
<% for (let i = 0; i < IC.length; i++) { -%>
const `verifier::IC<%= i %>` = stringHexToSlice("<%= IC[i] %>")
<% } -%>

// vk constants
const `verifier::vk_gamma_2` = stringHexToSlice("<%= vk_gamma_2 %>")
const `verifier::vk_delta_2` = stringHexToSlice("<%= vk_delta_2 %>")
const `verifier::vk_alpha_1` = stringHexToSlice("<%= vk_alpha_1 %>")
const `verifier::vk_beta_2`  = stringHexToSlice("<%= vk_beta_2 %>")

// public input dict settings
const `verifier::publicInputKeyLen` = <%= publicInputKeyLen %>
const `verifier::nPublic` = <%= nPublic %>

// error codes
const `verifier::err::public_not_present` = 257
const `verifier::err::too_many_publics` = 258
const `verifier::err::index_out_of_range` = 259
const `verifier::err::wrong_proof` = 260

// BLS intrinsics
@pure 
  fun blsG1Add(x: slice, y: slice): slice 
    asm "BLS_G1_ADD";
@pure 
  fun blsG1Neg(x: slice): slice       
    asm "BLS_G1_NEG";
@pure 
  fun blsPairing(
    x1: slice, y1: slice,
    x2: slice, y2: slice,
    x3: slice, y3: slice,
    x4: slice, y4: slice,
    n: int
  ): int asm "BLS_PAIRING";

<%
/* batching plan: max 7 pairs per MULTIEXP */
const maxBatch = 7;
let sizes = [];
if (nPublic <= 0) {
  sizes = [];
} else if (nPublic <= maxBatch) {
  sizes = [nPublic];
} else {
  const full = Math.floor(nPublic / maxBatch);
  for (let i = 0; i < full; i++) sizes.push(maxBatch);
  const rem = nPublic % maxBatch;
  if (rem > 0) sizes.push(rem);
}
const uniqSizes = [...new Set(sizes)];
const tailSizes = uniqSizes.filter(s => s !== 7).sort((a,b)=>a-b);
-%>

<% uniqSizes.forEach((k) => { -%>
@pure
fun blsG1Multiexp_<%= k %>(
<% for (let i = 1; i <= k; i++) { -%>
  x<%= i %>: slice, y<%= i %>: int<%= i<k ? "," : "" %>
<% } -%>
  , n: int
): slice asm "BLS_G1_MULTIEXP";
<% }); -%>

// slice helpers
fun slice.loadP1(mutate self): slice {
  var c: cell = self.loadRef();
  var s: slice = c.beginParse();
  var p1: slice = s.getFirstBits(`verifier::P1_SIZE`);
  s.skipBits(`verifier::P1_SIZE`);
  self = s; return p1;
}

fun slice.loadP2(mutate self): slice {
  var c: cell = self.loadRef();
  var s: slice = c.beginParse();
  var p2: slice = s.getFirstBits(`verifier::P2_SIZE`);
  s.skipBits(`verifier::P2_SIZE`);
  self = s; return p2;
}

<% if (IC.length > 1) { -%>
// IC selector for runtime index: 1 -> IC1, 2 -> IC2, ...
fun ic(idx: int): slice {
<% for (let i = 1; i < IC.length; i++) { -%>
  if (idx == <%= i %>) { return `verifier::IC<%= i %>`; }
<% } -%>
  throw(`verifier::err::index_out_of_range`);
}
<% } -%>

fun groth16Verify(
  piA: slice,
  piB: slice,
  piC: slice,
  pubInputs: dict
): bool {

<% if (nPublic === 0) { -%>
  // no public inputs: cpub = IC0
  var cpub: slice = `verifier::IC0`;
<% } else if (nPublic <= 7) { -%>
  // single batch (no loops; non-destructive dict access)
<% for (let i = 0; i < nPublic; i++) { -%>
  var (in<%= i %>: slice?, ok<%= i %>: bool) = pubInputs.uDictGet(`verifier::publicInputKeyLen`, <%= i %>);
  assert(ok<%= i %>, `verifier::err::public_not_present`);
  var v<%= i %>: int = in<%= i %>!.loadUint(256);
<% } -%>
  var cpub: slice = blsG1Multiexp_<%= nPublic %>(
<% for (let i = 0; i < nPublic; i++) { -%>
    `verifier::IC<%= i+1 %>`, v<%= i %><%= i<nPublic-1 ? "," : "" %>
<% } -%>
    , <%= nPublic %>
  );
<% } else { -%>
  // loop over full 7-sized batches using uDictGet (non-destructive)
  var done: int = 0;
  var full: int = `verifier::nPublic` / 7;
  var rem:  int = `verifier::nPublic` % 7;

  var haveCpub: bool = false;
  var cpub: slice = `verifier::IC0`; // replaced on first batch

  while (full > 0) {
    var in0: slice?; var ok0: bool; var v0: int;
    var in1: slice?; var ok1: bool; var v1: int;
    var in2: slice?; var ok2: bool; var v2: int;
    var in3: slice?; var ok3: bool; var v3: int;
    var in4: slice?; var ok4: bool; var v4: int;
    var in5: slice?; var ok5: bool; var v5: int;
    var in6: slice?; var ok6: bool; var v6: int;

    (in0, ok0) = pubInputs.uDictGet(`verifier::publicInputKeyLen`, done + 0); assert(ok0) throw `verifier::err::public_not_present`; v0 = in0!.loadUint(256);
    (in1, ok1) = pubInputs.uDictGet(`verifier::publicInputKeyLen`, done + 1); assert(ok1) throw `verifier::err::public_not_present`; v1 = in1!.loadUint(256);
    (in2, ok2) = pubInputs.uDictGet(`verifier::publicInputKeyLen`, done + 2); assert(ok2) throw `verifier::err::public_not_present`; v2 = in2!.loadUint(256);
    (in3, ok3) = pubInputs.uDictGet(`verifier::publicInputKeyLen`, done + 3); assert(ok3) throw `verifier::err::public_not_present`; v3 = in3!.loadUint(256);
    (in4, ok4) = pubInputs.uDictGet(`verifier::publicInputKeyLen`, done + 4); assert(ok4) throw `verifier::err::public_not_present`; v4 = in4!.loadUint(256);
    (in5, ok5) = pubInputs.uDictGet(`verifier::publicInputKeyLen`, done + 5); assert(ok5) throw `verifier::err::public_not_present`; v5 = in5!.loadUint(256);
    (in6, ok6) = pubInputs.uDictGet(`verifier::publicInputKeyLen`, done + 6); assert(ok6) throw `verifier::err::public_not_present`; v6 = in6!.loadUint(256);

    var tmp: slice = blsG1Multiexp_7(
      ic(done + 1), v0,
      ic(done + 2), v1,
      ic(done + 3), v2,
      ic(done + 4), v3,
      ic(done + 5), v4,
      ic(done + 6), v5,
      ic(done + 7), v6,
      7
    );
    if (!haveCpub) {
      cpub = tmp;
      haveCpub = true;
    } else {
      cpub = blsG1Add(cpub, tmp);
    }
    done += 7;
    full -= 1;
  }

  <% if (tailSizes.length) { -%>
  // tail batch (exact remainder handling)
  <% tailSizes.forEach((r, i) => { -%>
  <%= i === 0 ? 'if' : 'else if' %> (rem == <%= r %>) {
    <% for (let j = 0; j < r; j++) { -%>
    var inT<%= j %>: slice?; var okT<%= j %>: bool; var vT<%= j %>: int;
    (inT<%= j %>, okT<%= j %>) = pubInputs.uDictGet(`verifier::publicInputKeyLen`, done + <%= j %>);
    assert(okT<%= j %>) throw `verifier::err::public_not_present`;
    vT<%= j %> = inT<%= j %>!.loadUint(256);
    <% } -%>
    var tail: slice = blsG1Multiexp_<%= r %>(
      <% for (let j = 0; j < r; j++) { -%>
      ic(done + <%= j+1 %>), vT<%= j %><%= j < r-1 ? "," : "" %>
      <% } -%>
      , <%= r %>
    );
    if (!haveCpub) {
      cpub = tail;
      haveCpub = true;
    } else {
      cpub = blsG1Add(cpub, tail);
    }
    done += <%= r %>;
  }
  <% }); -%>
  <% } -%>
<% } -%>

  // add constant term
  cpub = blsG1Add(cpub, `verifier::IC0`);

  // pairing check
  var piANeg: slice = blsG1Neg(piA);
  var a: int = blsPairing(
    cpub,                 `verifier::vk_gamma_2`,
    piANeg,               piB,
    piC,                  `verifier::vk_delta_2`,
    `verifier::vk_alpha_1`, `verifier::vk_beta_2`,
    4
  );

  return (a == 0) ? false : true;
}

fun verify(inMsgBody: slice): bool {
  var piA: slice = inMsgBody.loadP1();
  var piB: slice = inMsgBody.loadP2();
  var piC: slice = inMsgBody.loadP1();
  var pubInputs = inMsgBody.loadDict();
  return groth16Verify(piA, piB, piC, pubInputs);
}

// in the future, use: fun onInternalMessage(in: InMessage)
fun onInternalMessage(myBalance: int, msgValue: int, inMsgFull: cell, inMsgBody: slice) {
  if (inMsgBody.isEmpty()) {
    return;
  }
  var cs: slice = inMsgFull.beginParse();
  var flags: int = cs.loadUint(4);
  if (flags & 1) {
    return;
  }
  var op: int = inMsgBody.loadUint(32);
  var queryId: int = inMsgBody.loadUint(64);

  if (op == OP_VERIFY) {
    var res: bool = verify(inMsgBody);
    assert(res, `verifier::err::wrong_proof`);
    return;
  }
  throw 0xffff;
}

get fun get_verify(
  piA: slice,
  piB: slice,
  piC: slice,
  pubInputs: slice
): bool {
  return groth16Verify(
    piA,
    piB,
    piC,
    pubInputs.loadDict()
  );
}
x