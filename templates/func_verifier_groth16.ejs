#include "imports/stdlib.fc";

;; ops
const op::verify = "op::verify"c;

;; input constants (IC0 is the base term)
<% for (let i = 0; i < IC.length; i++) { -%>
const slice verifier::IC<%= i %> = "<%= IC[i] %>"s;
<% } -%>

;; vk constants
const slice verifier::vk_gamma_2 = "<%= vk_gamma_2 %>"s;
const slice verifier::vk_delta_2 = "<%= vk_delta_2 %>"s;
const slice verifier::vk_alpha_1 = "<%= vk_alpha_1 %>"s;
const slice verifier::vk_beta_2  = "<%= vk_beta_2 %>"s;

;; public input dict settings
const int verifier::publicInputKeyLen = <%= publicInputKeyLen %>;
const int verifier::nPublic = <%= nPublic %>;

;; error codes
const int verifier::err::public_not_present = 257;
const int verifier::err::too_many_publics = 258;
const int verifier::err::index_out_of_range = 259;
const int verifier::err::wrong_proof = 260;

;; bls intrinsics
slice bls_g1_add(slice x, slice y) asm "BLS_G1_ADD";
slice bls_g1_neg(slice x) asm "BLS_G1_NEG";
int bls_pairing(slice x1, slice y1, slice x2, slice y2, slice x3, slice y3, slice x4, slice y4, int n) asm "BLS_PAIRING";

<%
const maxBatch = 7;
let sizes = [];
if (nPublic <= 0) {
  sizes = [];
} else if (nPublic <= maxBatch) {
  sizes = [nPublic];
} else {
  const full = Math.floor(nPublic / maxBatch);
  for (let i = 0; i < full; i++) sizes.push(maxBatch);
  const rem = nPublic % maxBatch;
  if (rem > 0) sizes.push(rem);
}

const uniqSizes = [...new Set(sizes)];
-%>

<% uniqSizes.forEach((k) => { -%>
slice bls_g1_multiexp_<%= k %>(
<% for (let i = 1; i <= k; i++) { -%>
    slice x<%= i %>, int y<%= i %><%= i<k ? "," : "" %>
<% } -%>
    , int n
) asm "BLS_G1_MULTIEXP";
<% }); -%>

(int) groth16Verify(
    slice piA,
    slice piB,
    slice piC,
    cell pubInputs
) impure {
    int res = 0;

<% if (nPublic === 0) { -%>
    ;; no public inputs: cpub = IC0
    ;; IMPORTANT: when nPublic == 0, pubInputs must be empty (no extra keys allowed)
    throw_unless(verifier::err::too_many_publics, null?(pubInputs));
    slice cpub = verifier::IC0;
<% } else { -%>

    ;; extract public inputs by keys 0..nPublic-1
<% for (let i = 0; i < nPublic; i++) { -%>
    (slice input<%= i %>, int ok<%= i %>) = pubInputs~udict_delete_get?(verifier::publicInputKeyLen, <%= i %>);
    throw_unless(verifier::err::public_not_present, ok<%= i %>);
    int val<%= i %> = input<%= i %>~load_uint(256);
<% } -%>

    ;; ensure the dict is now empty (no extra public inputs beyond 0..nPublic-1)
    throw_unless(verifier::err::too_many_publics, null?(pubInputs));

    ;; assemble cpub via batched MULTIEXP and summation
<%
let cursor = 1; // IC1..ICnPublic are used with val0..valN-1
let batchIndex = 0;
-%>
<% if (sizes.length === 1) { 
   const k = sizes[0]; -%>
    slice cpub = bls_g1_multiexp_<%= k %>(
<%   for (let i = 0; i < k; i++) { -%>
        verifier::IC<%= cursor + i %>, val<%= i %><%= i<k-1 ? "," : "" %>
<%   } -%>
        , <%= k %>
    );
<% } else { 

    let globalIdx = 0;
   sizes.forEach((k, bi) => { -%>
<%     if (bi === 0) { -%>
    slice cpub = bls_g1_multiexp_<%= k %>(
<%     } else { -%>
    cpub = bls_g1_add(cpub, bls_g1_multiexp_<%= k %>(
<%     } -%>
<%     for (let j = 0; j < k; j++) { -%>
        verifier::IC<%= cursor + globalIdx + j %>, val<%= globalIdx + j %><%= j<k-1 ? "," : "" %>
<%     } -%>
        , <%= k %>
    )<%= bi===0 ? ";" : ");" %>
<%     globalIdx += k; -%>
<%   }); -%>
<% } -%>

    ;; add the free term IC0
    cpub = bls_g1_add(cpub, verifier::IC0);
<% } -%>

    ;; pairing check
    slice piA_neg = bls_g1_neg(piA);
    int a = bls_pairing(
        cpub,              verifier::vk_gamma_2,
        piA_neg,          piB,
        piC,              verifier::vk_delta_2,
        verifier::vk_alpha_1, verifier::vk_beta_2,
        4
    );

    if (a == 0) {
        res = 0;
    } else {
        res = 1;
    }
    return (res);
}

(int) verifyProof(
    slice in_msg_body
) impure {
    slice piA = in_msg_body~load_ref().begin_parse();
    slice piB = in_msg_body~load_ref().begin_parse();
    slice piC = in_msg_body~load_ref().begin_parse();
    var pubInputs = in_msg_body~load_dict();

    return groth16Verify(
        piA,
        piB,
        piC,
        pubInputs
    );
}

() recv_internal(int my_balance, int msg_value, cell in_msg_full, slice in_msg_body) impure {
    if (in_msg_body.slice_empty?()) {
        return ();
    }
    slice cs = in_msg_full.begin_parse();
    int flags = cs~load_uint(4);
    if (flags & 1) {
        return ();
    }
    int op = in_msg_body~load_uint(32);

    if (op == op::verify) {
        int res = verifyProof(in_msg_body);
        throw_unless(verifier::err::wrong_proof, res == 1);
        return ();
    }
    throw(0xffff);
}

int verify(slice piA, slice piB, slice piC, slice pubInputs) method_id {
  return groth16Verify(piA, piB, piC, pubInputs~load_dict());
}
