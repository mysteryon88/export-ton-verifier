// ASM intrinsics
asm fun blsG1Add(x: Slice, y: Slice): Slice { BLS_G1_ADD }
asm fun blsG1Neg(x: Slice): Slice { BLS_G1_NEG }
asm fun blsPairing(
  x1: Slice, y1: Slice,
  x2: Slice, y2: Slice,
  x3: Slice, y3: Slice,
  x4: Slice, y4: Slice,
  n: Int
): Int { BLS_PAIRING }

<%
/* MULTIEXP batching: maximum 7 pairs per call */
const maxBatch = 7;
let sizes = [];
if (nPublic <= 0) {
  sizes = [];
} else if (nPublic <= maxBatch) {
  sizes = [nPublic];
} else {
  const full = Math.floor(nPublic / maxBatch);
  for (let i = 0; i < full; i++) sizes.push(maxBatch);
  const rem = nPublic % maxBatch;
  if (rem > 0) sizes.push(rem);
}
const uniqSizes = [...new Set(sizes)];
-%>

<% uniqSizes.forEach((k) => { -%>
asm fun blsG1Multiexp_<%= k %>(
<% for (let i = 1; i <= k; i++) { -%>
  x<%= i %>: Slice, y<%= i %>: Int<%= i<k ? "," : "" %>
<% } -%>
  , n: Int
): Slice { BLS_G1_MULTIEXP }
<% }); -%>

// Verification key constants
const vk_gamma_2: Slice = rawSlice("<%= vk_gamma_2 %>");
const vk_delta_2: Slice = rawSlice("<%= vk_delta_2 %>");
const vk_alpha_1: Slice = rawSlice("<%= vk_alpha_1 %>");
const vk_beta_2 : Slice = rawSlice("<%= vk_beta_2 %>");

// IC constants (IC0 — constant term)
<% for (let i = 0; i < IC.length; i++) { -%>
const IC<%= i %>: Slice = rawSlice("<%= IC[i] %>");
<% } -%>

// Error codes
const ERR_PUBLIC_NOT_PRESENT: Int = 257;
const ERR_TOO_MANY_PUBLICS: Int = 258;
const ERR_INDEX_OUT_OF_RANGE: Int = 259;
const ERR_WRONG_PROOF: Int = 260;

<% if (nPublic > 7) { -%>
// IC selection helper by index: 1 -> IC1, 2 -> IC2, ...
fun ic(idx: Int): Slice {
<% for (let i = 1; i < IC.length; i++) { -%>
  if (idx == <%= i %>) { return IC<%= i %>; }
<% } -%>
  return IC0; // Fallback
  // nativeThrow(ERR_INDEX_OUT_OF_RANGE);
}
<% } -%>

// Safe getter for public inputs: throws ERR_PUBLIC_NOT_PRESENT
fun getPub(pubInputs: map<Int as uint32, Int>, k: Int): Int {
  let v = pubInputs.get(k);
  if (v == null) {
    nativeThrow(ERR_PUBLIC_NOT_PRESENT);
  }
  return v!!;
}

// Message definition
message (0x3b3cca17) Verify {
  piA: Slice;
  piB: Slice;
  piC: Slice;
  pubInputs: map<Int as uint32, Int>;
}

contract Verifier {

  receive(msg: Verify) {
    let res = self.groth16Verify(msg.piA, msg.piB, msg.piC, msg.pubInputs);
    nativeThrowUnless(ERR_WRONG_PROOF, res);
  }

  receive() {}

  fun groth16Verify(
    piA: Slice,
    piB: Slice,
    piC: Slice,
    pubInputs: map<Int as uint32, Int>
  ): Bool {

    // --- acc = Σ(v_i * IC_{i+1}) (ONLY public-dependent part) ---
    let haveAcc: Bool = false;
    let acc: Slice = IC0; // placeholder until haveAcc=true

<% if (nPublic === 0) { -%>
    // No public inputs allowed
    nativeThrowIf(ERR_TOO_MANY_PUBLICS, pubInputs.exists(0));
<% } else if (nPublic <= 7) { -%>
    // Single batch (no loop and no ic())
    acc = blsG1Multiexp_<%= nPublic %>(
<%   for (let i = 0; i < nPublic; i++) { -%>
      IC<%= i+1 %>, getPub(pubInputs, <%= i %>)<%= i < nPublic-1 ? "," : "" %>
<%   } -%>
      , <%= nPublic %>
    );
    haveAcc = true;

    // Cheap guard: reject obvious extras
    nativeThrowIf(ERR_TOO_MANY_PUBLICS, pubInputs.exists(<%= nPublic %>));

<% } else {
   const full = Math.floor(nPublic / 7);
   const rem = nPublic % 7;
-%>
    // Loop over full batches of 7
    let done: Int = 0;
    let batchesLeft: Int = <%= full %>;

    while (batchesLeft > 0) {
      let tmp: Slice = blsG1Multiexp_7(
        ic(done + 1), getPub(pubInputs, done + 0),
        ic(done + 2), getPub(pubInputs, done + 1),
        ic(done + 3), getPub(pubInputs, done + 2),
        ic(done + 4), getPub(pubInputs, done + 3),
        ic(done + 5), getPub(pubInputs, done + 4),
        ic(done + 6), getPub(pubInputs, done + 5),
        ic(done + 7), getPub(pubInputs, done + 6),
        7
      );

      if (!haveAcc) {
        acc = tmp;
        haveAcc = true;
      } else {
        acc = blsG1Add(acc, tmp);
      }

      done += 7;
      batchesLeft -= 1;
    }

<%   if (rem > 0) { -%>
    // Tail batch for remaining <%= rem %>
    let tail: Slice = blsG1Multiexp_<%= rem %>(
<%     for (let j = 0; j < rem; j++) { -%>
      ic(done + <%= j+1 %>), getPub(pubInputs, done + <%= j %>)<%= j < rem-1 ? "," : "" %>
<%     } -%>
      , <%= rem %>
    );

    if (!haveAcc) {
      acc = tail;
      haveAcc = true;
    } else {
      acc = blsG1Add(acc, tail);
    }

    done += <%= rem %>;
<%   } -%>

    // Cheap guard: reject obvious extras
    nativeThrowIf(ERR_TOO_MANY_PUBLICS, pubInputs.exists(<%= nPublic %>));
<% } -%>

    // --- cpub = IC0 + acc (IC0 is added exactly once) ---
    let cpub: Slice = haveAcc ? blsG1Add(acc, IC0) : IC0;

    // Pairing check
    let piANeg: Slice = blsG1Neg(piA);
    let ok: Int = blsPairing(
      cpub,       vk_gamma_2,
      piANeg,     piB,
      piC,        vk_delta_2,
      vk_alpha_1, vk_beta_2,
      4
    );

    return ok != 0;
  }

  get fun verify(
    piA: Slice,
    piB: Slice,
    piC: Slice,
    pubInputs: map<Int as uint32, Int>
  ): Bool {
    return self.groth16Verify(piA, piB, piC, pubInputs);
  }
}
