const OP_VERIFY = stringCrc32("op::verify");
const P1_SIZE = 48 * 8;
const P2_SIZE = 96 * 8;

<% for (let i = 0; i < IC.length; i++) { -%>
const IC<%= i %> = stringHexToSlice("<%= IC[i] %>");
<% } -%>

const vk_gamma_2 = stringHexToSlice("<%= vk_gamma_2 %>");
const vk_delta_2 = stringHexToSlice("<%= vk_delta_2 %>");
const vk_alpha_1 = stringHexToSlice("<%= vk_alpha_1 %>");
const vk_beta_2  = stringHexToSlice("<%= vk_beta_2 %>");

@pure
fun blsG1Add(x: slice, y: slice): slice
    asm "BLS_G1_ADD";
@pure
fun blsG1Neg(x: slice): slice
    asm "BLS_G1_NEG";
@pure
fun blsG1Multiexp(
<% for (let i = 1; i <= nPublic; i++) { -%>
    x<%= i %>: slice, y<%= i %>: int,
<% } -%>
    n: int
): slice
    asm "BLS_G1_MULTIEXP";
@pure
fun blsPairing(x1: slice, y1: slice, x2: slice, y2: slice, x3: slice, y3: slice, x4: slice, y4: slice, n: int): int
    asm "BLS_PAIRING";

fun slice.loadP1(mutate self): slice {
    var c: cell = self.loadRef();
    var s: slice = c.beginParse();
    var p1: slice = s.getFirstBits(P1_SIZE);
    s.skipBits(P1_SIZE);
    self = s; return p1;
}

fun slice.loadP2(mutate self): slice {
    var c: cell = self.loadRef();
    var s: slice = c.beginParse();
    var p2: slice = s.getFirstBits(P2_SIZE);
    s.skipBits(P2_SIZE);
    self = s; return p2;
}

fun slice.loadNewint(mutate self): int {
    var c: cell = self.loadRef();
    var s: slice = c.beginParse();
    var x: int = s.loadUint(256);
    self = s; return x;
}

fun groth16Verify(
    piA: slice,
    piB: slice,
    piC: slice,
<% for (let i = 0; i < nPublic; i++) { -%>
    pubInput<%= i %>: int<%= i + 1 < nPublic ? "," : "" %>
<% } -%>
): int {
    var res: int = 0;
<% if (nPublic > 0) { -%>
    var cpub: slice = blsG1Multiexp(
<% for (let i = 1; i <= nPublic; i++) { -%>
        IC<%= i %>, pubInput<%= i - 1 %>,
<% } -%>
        <%= nPublic %>
    );
    cpub = blsG1Add(cpub, IC0);
<% } else { -%>
    var cpub: slice = IC0;
<% } -%>
    var piANeg: slice = blsG1Neg(piA);
    var a: int = blsPairing(
        cpub,       vk_gamma_2,
        piANeg,     piB,
        piC,        vk_delta_2,
        vk_alpha_1, vk_beta_2,
        4
    );
    if (a == 0) {
        res = 0;
    } else {
        res = 1;
    }
    return res;
}

fun verify(inMsgBody: slice): int {
    var piA: slice = inMsgBody.loadP1();
    var piB: slice = inMsgBody.loadP2();
    var piC: slice = inMsgBody.loadP1();
<% for (let i = 0; i < nPublic; i++) { -%>
    var pubInput<%= i %>: int = inMsgBody.loadNewint();
<% } -%>
    return groth16Verify(
        piA,
        piB,
        piC,
<% for (let i = 0; i < nPublic; i++) { -%>
        pubInput<%= i %><%= i + 1 < nPublic ? "," : "" %>
<% } -%>
    );
}

fun onInternalMessage(myBalance: int, msgValue: int, inMsgFull: cell, inMsgBody: slice) {
    if (inMsgBody.isEmpty()) {
        return;
    }
    var cs: slice = inMsgFull.beginParse();
    var flags: int = cs.loadUint(4);
    if (flags & 1) {
        return;
    }
    var op: int = inMsgBody.loadUint(32);
    var queryId: int = inMsgBody.loadUint(64);
    if (op == OP_VERIFY) {
        var res: int = verify(inMsgBody);
        return;
    }
    throw 0xffff;
}

get fun get_verify(
    piA: slice,
    piB: slice,
    piC: slice,
<% for (let i = 0; i < nPublic; i++) { -%>
    pubInput<%= i %>: int<%= i + 1 < nPublic ? "," : "" %>
<% } -%>
): int {
    return groth16Verify(
        piA,
        piB,
        piC,
<% for (let i = 0; i < nPublic; i++) { -%>
        pubInput<%= i %><%= i + 1 < nPublic ? "," : "" %>
<% } -%>
    );
}
